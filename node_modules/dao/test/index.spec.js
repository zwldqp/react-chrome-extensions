import assert from 'power-assert';
import axios from 'axios';
import sinon from 'sinon';
import dao, {axios as daoAxios} from '../lib';

describe('#dao.parseURL', function () {
    it('Should parse url pattern correctly', () => {
        const params = {
            id: 1
        }
        const data = {
            shopId: 2,
            extra: 'some extra data'
        }
        const url = dao.parseURL('/books/:id?shop=:shopId', params, data)
        assert(url, '/books/1?shop=2')
        assert.equal(params.id, undefined)
        assert.equal(data.shopId, undefined)
    })

    it('Should throw error if missing fields when parsing url pattern', () => {
        assert.throws(() => {
            dao.parseURL('/books/:id', {})
        }, Error)
    })
})

describe('#dao.create', function () {
    it('Should create dao instance without error', function () {
        assert.doesNotThrow(() => {
            const userDAO = dao.create({
                get: '/api/users/:id',
                getList: {
                    url: '/api/users',
                    loading: true
                },
                update: {
                    url: '/api/users/:id',
                    method: 'post',
                    getLatest: true
                },
                delete: {
                    url: '',
                    method: 'delete',
                    preventRepeated: true
                },
                patch: {
                    url: '',
                    method: 'PATCH',
                    preventNotification: true
                }
            })
        })
    })
})

describe('#dao.handlers', function () {
    let userDAO = null
    let params = null
    let server = null;
    beforeEach(function () {
        params = { id: 1 }
        dao.handlers = {
            showLoading: sinon.spy(),
            hideLoading: sinon.spy(),
            displayNotification: sinon.spy(),
        };
        userDAO = dao.create({
            get: '/api/users/:id',
            update: {
                url: '/api/users/:id',
                method: 'POST'
            },
            delete: {
                url: '/api/users/:id',
                method: 'DELETE'
            }
        })
        server = sinon.fakeServer.create()
        server.respondWith(
            'GET',
            /\/api\/users\/1\?.*/,
            [ 200, {'Content-Type': 'application/json'}, JSON.stringify({ id: 1 }) ],
        )
        server.respondWith(
            'POST',
            '\/api\/users\/1',
            [ 200, {'Content-Type': 'application/json'}, JSON.stringify({ status: 0 }) ],
        )
    })
    afterEach(function () {
        dao.handlers = {}
        userDAO = null
        params = null
        server.restore()
    })
    it('Should return promise when calling dao method', () => {
        const promise = userDAO.get({ params } )
        assert.ok(promise instanceof Promise)
    })
    it('Should not call loading handler when http method equal "GET"', (done) => {
        server.autoRespond = true
        userDAO.get({ params }).then((res) => {
            assert.ok(dao.handlers.showLoading.notCalled)
            assert.ok(dao.handlers.hideLoading.notCalled)
            done()
        })
    })
    it('Should call loading handler when loading set to true', (done) => {
        server.autoRespond = true
        userDAO.get({ params, loading: true }).then((response) => {
            assert.ok(dao.handlers.showLoading.called)
            assert.ok(dao.handlers.hideLoading.called)
            assert.ok(dao.handlers.showLoading.calledBefore(dao.handlers.hideLoading))
            done()
        })
    })
    it('Should call loading handler when http method equal "POST"', (done) => {
        server.autoRespond = true
        userDAO.update({ params }).then(() => {
            assert.ok(dao.handlers.showLoading.called)
            assert.ok(dao.handlers.hideLoading.called)
            assert.ok(dao.handlers.showLoading.calledBefore(dao.handlers.hideLoading))
            done()
        })
    })
    it('Should not call loading handler when loading set to false', (done) => {
        server.autoRespond = true
        userDAO.update({ loading: false, params }).then(() => {
            assert.ok(dao.handlers.showLoading.notCalled)
            assert.ok(dao.handlers.hideLoading.notCalled)
            done()
        })
    })
    it('Should call displayNotification when catch error', (done) => {
        server.respondWith(
            'DELETE',
            '/api/users/1',
            [ 500, {}, '']
        )
        server.autoRespond = true
        userDAO.delete({ params }).catch(() => {
            assert.ok(dao.handlers.displayNotification.called)
            done()
        })
    })
    it('Should not call displayNotification when preventNotification set to true', done => {
        server.respondWith(
            'DELETE',
            '/api/users/1',
            [ 500, {}, '']
        )
        server.autoRespond = true
        userDAO.delete({ preventNotification: true, params }).catch(() => {
            assert.ok(dao.handlers.displayNotification.notCalled)
            done()
        })
    })
})

describe('#dao.takeLatest', function () {
    let userDAO = null
    let server = null
    beforeEach(function () {
        userDAO = dao.create({
            get: '/api/users/:id',
        })
        server = sinon.fakeServer.create()
    })
    afterEach(function () {
        userDAO = null
        server.restore()
    })
    it('Should only take the latest request when takeLatest set to true', done => {
        const onCancel = sinon.spy()
        const getUser = () => {
            const params = { id: 1 }
            return userDAO.get({ params, takeLatest: true })
        }
        server.respondWith(
            'GET',
            /\/api\/users\/1\?.*/,
            [ 200, { 'Content-Type': 'application/json' }, JSON.stringify({ id: 1 }) ]
        )
        server.autoRespond = true
        getUser().catch(ex => {
            onCancel()
            assert.ok(axios.isCancel(ex))
        })
        getUser().catch(ex => {
            onCancel()
            assert.ok(axios.isCancel(ex))
        })
        getUser().then(() => {
            assert.ok(onCancel.calledTwice)
            done()
        })
    })
})

describe('#dao.preventRepeated', function () {
    let userDAO = null
    let server = null
    beforeEach(function () {
        userDAO = dao.create({
            update: {
                url: '/api/users/:id',
                method: 'POST'
            }
        })
        server = sinon.fakeServer.create()
    })
    afterEach(function () {
        userDAO = null
        server.restore()
    })
    it('Should prevent repeat request when preventRepeated set to true', (done) => {
        server.respondWith(
            'POST',
            '/api/users/1',
            [ 200, { 'Content-Type': 'application/json' }, JSON.stringify({ id: 1 }) ]
        )
        server.autoRespond = true
        const onPrevented = sinon.spy()
        const updateUser = () => {
            const params = { id: 1 }
            return userDAO.update({ params, preventRepeated: true })
        }
        updateUser().then(() => {
            assert.ok(onPrevented.calledTwice)
            done()
        })
        updateUser().catch(() => {
            onPrevented()
        })
        updateUser().catch((error) => {
            onPrevented()
            assert.ok(error instanceof Error)
        })
    })
})

describe('#dao.axios', function () {
    it('Should export axios from dao', () => {
        assert.ok(typeof daoAxios === 'function')
        assert.ok(typeof daoAxios.get === 'function')
        assert.ok(typeof daoAxios.create === 'function')
        assert.ok(typeof daoAxios.interceptors === 'object')
    })

    it('Should send request succeed use dao.axios', (done) => {
        const server = sinon.fakeServer.create()
        server.respondWith(
            'POST',
            '/api/users/1',
            [ 200, { 'Content-Type': 'application/json' }, JSON.stringify({ id: 1 }) ]
        )
        server.autoRespond = true
        daoAxios.post('/api/users/1').then((resp) => {
            assert.equal(resp.data.id, 1);
            done();
        });
    })
});

describe('#dao.axios.get', function () {
    it('Should the params include _t', function (done) {
        dao.interceptors.request.use(config => {
            assert.ok(typeof(config.params._t) === 'number');
            done();
        })
        const testDao = dao.create({
            get: '/api/users'
        });
        testDao.get({params: {x: 123}});
    });
    it('Should the params  include _t  when it is undefined', function (done) {
        dao.interceptors.request.use(config => {
            assert.ok(typeof(config.params._t) === 'number');
            done();
        })
        const testDao = dao.create({
            get: '/api/users'
        });
        testDao.get();
    });
    it('Should the params not include _t when http method equal "POST"', function (done) {
        dao.interceptors.request.use(config => {
            assert.ok(config.params._t === undefined);
            done();
        })
        const testDao = dao.create({
            update: {
                url: '/api/users', 
                method: 'POST',
            },
            
        });
        testDao.update({params: {x: 123}});
    });

});