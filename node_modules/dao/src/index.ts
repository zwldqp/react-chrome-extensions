import axios, {
    AxiosRequestConfig,
    AxiosPromise,
    AxiosInstance,
    AxiosResponse,
    AxiosError,
    AxiosInterceptorManager,
    Cancel,
} from 'axios';

export interface DAOInterceptorManager<V> extends AxiosInterceptorManager<V> {}

export interface DAORequestConfig extends AxiosRequestConfig {
    loading?: boolean;
    takeLatest?: boolean;
    preventRepeated?: boolean;
    preventNotification?: boolean;
}

export interface DAOInitialSettings {
    [methodName: string]: string | DAORequestConfig;
}

export interface DAOInstance {
    [methodName: string]: DAOMethod;
}

export interface DAOMethod {
    (config?: DAORequestConfig): AxiosPromise;
}

export interface DAOResponse extends AxiosResponse {
    config: DAORequestConfig;
}

export interface DAOError extends AxiosError {
    config: DAORequestConfig;
}

export { axios };

const noop = function () {};

const handlers = {
    showLoading: noop,
    hideLoading: noop,
    displayNotification (error: AxiosError) {},
    requestShouldLoading (config: DAORequestConfig) {
        if (config.hasOwnProperty('loading')) {
            return config.loading;
        }
        const method = config.method.toUpperCase();
        return ['POST', 'PUT', 'DELETE', 'PATCH'].indexOf(method) !== -1;
    },
};

const CancelToken = axios.CancelToken;

const isCancel = axios.isCancel.bind(axios);

const requestCache = (function () {
    const store = {};
    const getRequestId = function (config: DAORequestConfig) {
        return `${config.method}-${config.url}`;
    };
    return {
        set (config: DAORequestConfig, data: any) {
            store[getRequestId(config)] = data;
        },
        get (config: DAORequestConfig) {
            return store[getRequestId(config)];
        },
        has (config: DAORequestConfig) {
            return store.hasOwnProperty(getRequestId(config));
        },
        remove (config: DAORequestConfig) {
            delete store[getRequestId(config)];
        },
    };
})();

const dao = {

    interceptors: {
        request: <DAOInterceptorManager<DAORequestConfig>>axios.interceptors.request,
        response: <DAOInterceptorManager<DAORequestConfig>>axios.interceptors.response,
    },

    handlers: { ...handlers },

    parseURL (urlPattern:string, params:{[key:string]:any} = {}, data: {[key: string]:any} = {}) {
        const re = /:([a-zA-Z0-9_]+)/g;
        const url = urlPattern.replace(re, (m, field) => {
            if (params.hasOwnProperty(field)) {
                const value = params[field];
                delete params[field];
                return value;
            } 
            if (data.hasOwnProperty(field)) {
                const value = data[field];
                delete data[field];
                return value;
            }
            throw new Error(`Cannot find params "${field}" to parse url pattern "${urlPattern}"`);
        });
        return url;
    },

    create (settings:DAOInitialSettings) {
        const instance = <DAOInstance>{};
        Object.keys(settings).forEach((methodName) => {
            const conf = settings[methodName];
            const initialConfig = typeof conf === 'string' ? { url: conf } : conf;
            const method: DAOMethod = function (config: DAORequestConfig) {
                const options = <any>{ ...initialConfig, ...config };
                options.method = options.method || 'GET';
                options.urlPattern = options.url;
                if (options.method.toUpperCase() === 'GET') {
                    options.params = options.params || {};
                    options.params._t = +new Date();
                }
                options.url = dao.parseURL(options.urlPattern, options.params, options.data);
                options.loading = getHandlers().requestShouldLoading(options);
                if (options.takeLatest) {
                    const prevSource = requestCache.get(options);
                    prevSource && prevSource.cancel();
                    const source = CancelToken.source();
                    options.cancelToken = source.token;
                    requestCache.set(options, source);
                }
                if (!options.takeLatest && options.preventRepeated) {
                    if (requestCache.has(options)) {
                        return Promise.reject(new Error(`dao: detected repeated request.`));
                    }
                    requestCache.set(options, true);
                }
                return axios(options);
            };
            instance[methodName] = method;
        });
        return instance;
    },

};

const getHandlers = function () {
    return { ...handlers, ...dao.handlers };
};

dao.interceptors.request.use((config: DAORequestConfig) => {
    if (config.loading) {
        getHandlers().showLoading();
    }
    return config;
});

dao.interceptors.response.use(
    (response: DAOResponse) => {
        const config = response.config;
        if (!config) {
            return response;
        }
        if (config.loading) {
            getHandlers().hideLoading();
        }
        if (config.takeLatest && requestCache.has(config)) {
            requestCache.remove(config);
        }
        if (!config.takeLatest && config.preventRepeated) {
            requestCache.remove(config);
        }
        return response;
    },
    (error: DAOError | Cancel) => {
        // if request was canceled, error is instanceof axios.Cancel
        if (!isCancel(error)) {
            const config = (<DAOError>error).config;
            const handlers = getHandlers();
            if (!config) {
                return error;
            }
            if (config.loading) {
                handlers.hideLoading();
            }
            if (config.takeLatest && requestCache.has(config)) {
                requestCache.remove(config);
            }
            if (!config.takeLatest && config.preventRepeated) {
                requestCache.remove(config);
            }
            if (!config.preventNotification) {
                handlers.displayNotification(<DAOError>error);
            }
        }
        return Promise.reject(error);
    },
);

export default dao;
