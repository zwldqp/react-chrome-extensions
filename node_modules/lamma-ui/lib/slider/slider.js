'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _rcSlider = require('rc-slider');

var _rcSlider2 = _interopRequireDefault(_rcSlider);

var _tooltip = require('../tooltip/tooltip');

var _tooltip2 = _interopRequireDefault(_tooltip);

var _inputNumber = require('../input-number/input-number');

var _inputNumber2 = _interopRequireDefault(_inputNumber);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var Handle = _rcSlider2.default.Handle;

var handle = function handle(props) {
    var value = props.value,
        dragging = props.dragging,
        index = props.index,
        restProps = _objectWithoutProperties(props, ['value', 'dragging', 'index']);

    return _react2.default.createElement(
        _tooltip2.default,
        {
            prefixCls: 'rc-slider-tooltip',
            overlay: value,
            visible: dragging,
            placement: 'top',
            key: index
        },
        _react2.default.createElement(Handle, _extends({ value: value }, restProps))
    );
};

/**
 * @author sunyue
 *
 * 组件基于 [rc-slider](http://react-component.github.io/slider/)
 */

var Slider = function (_React$Component) {
    _inherits(Slider, _React$Component);

    function Slider(props) {
        _classCallCheck(this, Slider);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

        _this.state = { inputValue: _this.props.value ? _this.props.value : _this.props.defaultValue };
        return _this;
    }

    Slider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (!('value' in nextProps)) return;

        var prevValue = this.state.inputValue;
        var nextValue = nextProps.value ? nextProps.value : prevValue;

        if (nextValue === prevValue) return;

        this.setState({
            inputValue: nextValue
        });
    };

    Slider.prototype.handleChange = function handleChange(value) {
        var inputvalue = Number.parseInt(value, 10);
        if (!inputvalue) return;

        var displayValue = this.props.value ? this.props.value : inputvalue;
        this.setState({
            inputValue: displayValue
        });
        if (this.props.onChange) {
            this.props.onChange(displayValue);
        }
    };

    Slider.prototype.render = function render() {
        var _this2 = this;

        var _props = this.props,
            isRange = _props.isRange,
            hasTooltip = _props.hasTooltip,
            hasInput = _props.hasInput,
            max = _props.max,
            min = _props.min,
            step = _props.step,
            classNames = _props.classNames,
            dots = _props.dots,
            defaultValue = _props.defaultValue,
            others = _objectWithoutProperties(_props, ['isRange', 'hasTooltip', 'hasInput', 'max', 'min', 'step', 'classNames', 'dots', 'defaultValue']);

        var sliderType = isRange ? _react2.default.createElement(_rcSlider.Range, _extends({
            className: 'rc-slider'
        }, this.props, {
            handle: hasTooltip ? handle : null
        })) : _react2.default.createElement(_rcSlider2.default, _extends({
            className: 'rc-slider'
        }, this.props, {
            handle: hasTooltip ? handle : null
        }));

        var inputnumber = hasInput ? _react2.default.createElement(
            'div',
            null,
            _react2.default.createElement(_inputNumber2.default, {
                className: 'rc-slider-set-input',
                size: 'small',
                value: this.state.inputValue,
                onChange: function onChange(e) {
                    return _this2.handleChange(e);
                },
                max: max,
                min: min,
                step: step
            }),
            _react2.default.createElement(_rcSlider2.default, {
                className: 'rc-slider',
                onChange: function onChange(e) {
                    return _this2.handleChange(e);
                },
                defaultValue: defaultValue,
                value: this.state.inputValue,
                max: max,
                min: min,
                step: step,
                dots: dots,
                handle: hasTooltip ? handle : null
            })
        ) : sliderType;

        return _react2.default.createElement(
            'div',
            _extends({ className: 'rc-slider-set' }, others),
            inputnumber
        );
    };

    return Slider;
}(_react2.default.Component);

exports.default = Slider;


Slider.propTypes = {
    /**
    * 是否有 Tooltip
    */
    hasTooltip: _propTypes2.default.bool,
    /**
    * 是否为范围 Slider
    */
    isRange: _propTypes2.default.bool,
    /**
    * 是否为范围 Slider
    */
    range: _propTypes2.default.bool,
    /**
    * 是否带有输入框
    */
    hasInput: _propTypes2.default.bool,
    /**
    * slider样式
    */
    classNames: _propTypes2.default.string,
    /**
    * range模式下可取到的最大值
    */
    max: _propTypes2.default.number,
    /**
    * range模式下可以取到的最小值
    */
    min: _propTypes2.default.number,
    /**
    * 步长，取值必须大于0，并且可以被(max - min)整除
    */
    step: _propTypes2.default.number,
    /**
    * 是否只能拖拽到刻度上
    */
    dots: _propTypes2.default.bool,
    /**
    * 设置当前取值
    */
    disabled: _propTypes2.default.bool,
    /**
    * 当slider的值发生改变时，会触发onChange事件
    */
    onChange: _propTypes2.default.func,
    /**
    * 默认值
    */
    defaultValue: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.array]),
    /**
    * 选择 Slider 就传数字，选择 Range 则传入数组～
    */
    value: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.array])
};

Slider.defaultProps = {
    hasTooltip: true,
    isRange: false,
    hasInput: false,
    classNames: '',
    max: 100,
    min: 0,
    step: 1,
    dots: false,
    disabled: false,
    onChange: function onChange() {},

    defaultValue: 1
};